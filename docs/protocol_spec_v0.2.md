# Спецификация протокола CD-BUS v0.2.1

**Статус:** Draft / Experimental
**Дата:** 18.12.2025
**Транспорт:** ESP-NOW (802.11 Action Frames)

## 1. Концепция

Система представляет собой распределенную сеть управления (DCS), работающую внутри экранированного корпуса.
RPi выступает в роли Оркестратора и Шлюза, но не является прямым звеном в петле управления реального времени (RT).

### Основные принципы

1. **JIT Profiles:** Профили экстракции передаются потоково. Исполнители хранят буфер только на несколько секунд вперед.
2. **Vector State:** Управление идет не по одному параметру, а вектором `{Время, Температура, Давление, Поток}` с флагом приоритета.
3. **Event Driven UI:** Органы управления (кнопки, ручки) являются "слепыми" источниками событий. Логика реакции определяется RPi.
4. **Haptic Feedback:** Ручки управления имеют программно-изменяемую физику (отдача, щелчки, упоры).

---

## 2. Типы Устройств и Роли

### 2.1. Датчики (Sensors Array)

Устройства, транслирующие физические параметры.

- **Примеры:** Термопары бойлеров, датчики уровня.
- **Поведение:**
  - В покое: Низкая частота опроса (1 Гц) для мониторинга.
  - В работе: Высокая частота (10-20 Гц) для PID и сбора данных "Энергии".
  - Пакеты могут объединять данные нескольких сенсоров (`DATA_MULTI`).

### 2.2. Умные Весы (Gravimetric Sensor)

Ключевой элемент обратной связи.

- **Функция:** Измерение веса и вычисление **выходного потока** (производной массы).
- **События:**
  - `EVENT_FLOW_START`: Детекция "первой капли" (начало реальной экстракции).
  - `EVENT_TARGET_REACHED`: Достижение целевого веса (триггер остановки).
- **Особенности:** Используют встроенный цифровой фильтр вибраций помпы.

### 2.3. Исполнители (Smart Actuators)

- **Помпа (Pump):** \* Управляется по **Потоку (мл/сек)**, а не просто мощностью.
  - Имеет таблицу калибровки "Обороты -> Объем".
- **Нагреватели (Heaters):**
  - Получают уставку температуры (Target Temp).
  - Сами реализуют PID-регулирование.
  - Передают обратно `%` мощности (Duty Cycle) для расчета энергии.

### 2.4. Haptic Interface (Ручки с экранами)

Уникальный узел взаимодействия.

- **Ввод:** Вращение энкодера, нажатие.
- **Вывод (Экран):** Отображает виджеты по команде RPi (не рендерит графику сам).
- **Вывод (Тактильный):**
  - _Mode Free:_ Свободное вращение.
  - _Mode Detents:_ Виртуальные щелчки (для меню).
  - _Mode Spring:_ Пружинный возврат (для ручного профилирования давления).
  - _Mode Servo:_ Принудительное вращение мотором (автоматизация).

### 2.5. Простые UI (Buttons/Levers)

- Транслируют сырые события: `CLICK_SHORT`, `HOLD_START`, `LEVER_POSITION`.
- Индикация (LED) управляется командами от RPi.

---

## 3. Модель Управления (Profiles)

Управление процессом варки происходит через сообщение `CMD_PROFILE_STEP`.
Каждый шаг профиля содержит вектор целей. Так как гидравлически невозможно одновременно гарантировать и Поток, и Давление, используется **Приоритет**.

| Режим               | Описание                                                    | Применение                         |
| :------------------ | :---------------------------------------------------------- | :--------------------------------- |
| `PRIORITY_FLOW`     | Помпа держит заданный поток любой ценой. Давление вторично. | Предсмачивание, заполнение группы. |
| `PRIORITY_PRESSURE` | Система стремится удержать давление. Поток подстраивается.  | Классическая экстракция (9 бар).   |
| `PRIORITY_HYBRID`   | Экспериментальный режим для R&D (баланс энергии).           | Исследование вкуса.                |

---

## 4. Маршрутизация

- **Топология:** Mesh с ограничением в 1 хоп.
- **Адресация:** Логические ID (`HU_DEV_xxx`).
- **Таблица:** Статическая. Загружается при старте или калибровке.

## 5. Адресация и Регистрация (Provisioning)

Протокол разделяет понятие **Типа устройства** (зашито в прошивку) и **Логического Адреса** (назначается RPi).

### 5.1. Адресное пространство

- `0x01`: **Coordinator** (RPi).
- `0xFE`: **Unassigned**. Адрес по умолчанию для новых устройств.
- `0xFF`: **Broadcast**. Всем.
- `0x10 .. 0xF0`: **Dynamic IDs**. Рабочий диапазон адресов узлов.
- `0x02 .. 0x09`, `0xF1 .. 0xFD`: **RESERVED**. Зарезервировано.

### 5.2. Процедура Discovery (Поиск)

Используется для обнаружения устройств и их инвентаризации.

1. **RPi** посылает `SYS_DISCOVERY_REQ` (Broadcast).
2. **Все узлы** отвечают `SYS_DISCOVERY_RES` с задержкой (random jitter 0..100ms), чтобы избежать коллизий.
3. **Payload ответа:** `{ DeviceType, HW_Rev, FW_Ver, Current_ID }`.

### 5.3. Процедура Assign ID (Назначение)

Используется для привязки физического устройства к логической роли.

1. **RPi** формирует пакет `SYS_ASSIGN_ID`.
2. **Payload:** `{ Target_MAC[6], New_ID }`.
3. **RPi** отправляет пакет на адрес `0xFF` (Broadcast) или `0xFE` (Unassigned).
4. **Узел** сверяет `Target_MAC` в пакете со своим собственным.
   - Если совпадает: Сохраняет `New_ID` в NVS (Non-Volatile Storage) и перезагружается.
   - Если не совпадает: Игнорирует.

### 5.4. Пример жизненного цикла

1. Установлено 2 одинаковых бойлера (Type `BOILER_PID`). Оба имеют адрес `0xFE`.
2. Инженер через UI запускает "Поиск". RPi видит два MAC-адреса: `...AA` и `...BB`.
3. Инженер отправляет команду "Идентифицировать `...AA`" (Узел мигает светодиодом).
4. Инженер назначает: "Это Бойлер Кофе".
5. RPi шлет `ASSIGN_ID` (`Target=...AA`, `ID=0x10`).
6. Теперь RPi знает, что `0x10` — это левый бойлер, и шлет ему профили.
